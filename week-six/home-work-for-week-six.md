# 题目 01：

一条 SQL 语句在 MySQL 中是如何执行的？

# 题目 02

请解释一下你理解的事务是什么？ 要点：

1. 事务四大特性 ACID
2. 事务隔离级别
3. 事务会产生的并发问题
4. 事务的安全性、性能与隔离级别的关系



答：

**题目01**：

答：通常我们执行一条 SQL 语句是从客户端发起的，然后通过网络请求连接到 MySQL 服务器端的。

我们要知道一条 SQL 语句在 MySQL 中如何执行的，先得知道 MySQL 的基本架构。大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。Server 层包括**连接器**、**查询缓存**、**分析器**、**优化器、执行器**等。存储引擎负责数据的存储和提取，其架构是插件式的，支持InnoDB、MyISAM等多个存储引擎，最常用的是 InnoDB。

第一步，你会先连上 MySQL，首先对接的连接器，它负责跟客户端建立连接、获取权限、维持和管理连接。

第二步，建立完成连接后，就开始执行 SQL 语句了。如果是查询语句，执行逻辑的就是查询缓存。如果是之前执行过的语句，缓存结果中就可能存在语句与结果的 key-value 的记录，那就直接返回这个 value 给客户端。但是只要对应表被更新了，缓存就会失效，所以大多数情况下MySQL 的缓存是利大于弊。

第三步，没有命中查询缓存，就是要开始真正执行语句了，就是到了分析器。分析器就是做“词法分析”，客户端传输过来的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。比如从“select”关键字识别出是查询语句，“update”是更新语句。然后是做“语法分析”，根据语法规则，判断输入的 SQL 语句是否满足 MySQL 的语法。不满足就会终止执行，返回错误提示给客户端。

第四步，经过前一步的分析器，MySQL 就知道你要做什么了。在开始执行之前，还要经过优化器的处理，这里是决定是否使用索引，如果多表关联决定各个表的连接顺序。接下来就是执行器阶段。

第五步，执行器阶段，开始执行之前，还要判断一下是否有相应表的权限，如果没有返回错误提示。如果有，就根据配置，使用对应存储引擎的接口去执行 SQL 语句。



**题目02**:

答：事务指的是逻辑上的一组操作，组成这组操作的各个单元要么全都成功，要么全都失败。

事务的作用：保证在一个事务中多次 SQL 操作要么全都成功，要么全都失败。



事务具有四大特性，简称ACID。

- 原子性（Atomicity）：指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。

- 一致性（Consistency）：事务前后数据的完整性必须保持一致。

- 隔离性（Isolation）：多个用户并发访问数据库时，一个用户的事务不能被其他的事物所干扰，多个并发事物之间数据要相互隔离。隔离性由隔离级别保障。

- 持久性（Durability）：一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有影响。

  

**事务隔离级别**

- 读未提交（read uncommitted，RU）：一个事务读到另一个事务没有提交的数据。存在三个问题：脏读、不可重复读、欢读。
- 读已提交（read committed，RC）：一个事务读到另一个事务已经提交的数据。存在两个问题：不可重复读、幻读。
- 可重复读（repeatable read，RR）：在一个事务中读到的数据始终保持一致，无论另一个事务是否提交。
- 串行化（serializable）：同时只能执行一个事务，相当于事务中的单线程。



**事务会产生的并发问题：**

- 脏读：一个事务读到了另一个事务未提交的数据。
- 不可重复读：一个事务读到了另一个事务已经提交（update）的数据。引发事务中的多次查询结果不一致。
- 虚读/幻读：一个事务读到另一个事务已经插入（insert）的数据。导致事务中多次查询的结果不一致。
- 丢失更新问题。



**事务的安全性、性能与隔离级别的关系**

事务的隔离级别越高，安全性就越高，但同时性能也就由强变弱了，隔离级别由低到高依次是：读未提交、读已提交、可重复读、串行化。