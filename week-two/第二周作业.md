第二周作业

# JVM 虚拟机论述题

## 题目 01- 请你用自己的语言向我介绍 Java 运行时数据区（内存区域）

- 堆、虚拟机栈、本地方法栈、方法区（永久代、元空间）、运行时常量池（字符串常量池）、直接内存
- 为什么堆内存要分年轻代和老年代？

### 答：

Java 虚拟机在执行 Java 程序的过程中，会把它管理的内存划分为若干个不同的数据区域，包含：堆、虚拟机栈、本地方法栈、方法区（包含运行时常量池）、程序计数器，这些区域统称为 Java 运行时数据区。

其中的堆、方法区是所有线程共享的，虚拟机栈、本地方法栈、程序计数器是当前线程私有的。

Java 堆在 Java 虚拟机启动时被创建的，唯一目的是存放对象实例，是虚拟机管理的最大的一块内存区域，也是垃圾收集器管理的区域。其中存放的 Java 对象实例是有生命周期的，会产生，也会销毁。为了更好的管理堆内存，我们通常把堆内存分为新生代和老年代（JDK 1.8）两个主要区域，新生代中又分为 Eden、Survivor空间。新生代主要存放新生成的对象，当进行一定次数的垃圾回收后还存活的对象就会被转移至老年代。Java 堆的大小是可拓展的，可以通过参数来进行设定，当堆内存满了后，Java 虚拟机会抛出 OutOfMemoryError 异常。

虚拟机栈是描述 Java 方法执行的线程内存模型，生命周期和线程相同，用于存放线程执行时调用的方法，每个被执行的方法都会生成一个栈帧，以栈帧的形式存放进虚拟机栈中，栈帧中保存了局部变量表、操作数栈、动态连接、方法出口等信息。栈帧以先进后出的方式保存在虚拟机栈中。

本地方法栈是虚拟机为执行本地方法服务的。

方法区是用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。方法区的具体实现在不同版本的 Java 中是不同的，JDK 1.8 前实现是永久代，JDK 1.8 后实现是元空间。永久代是存放在虚拟机进程所使用的区域，会影响虚拟机可使用的内存大小，元空间是使用了虚拟机外的本地内存。具体来说，元空间是把方法区原先包含的字符串常量池、静态变量等挪到堆后的剩余内容（主要是类型信息）。

运行时常量池属于方法区的一部分，一个 Class 文件对应一个运行时常量池，其中又有一个整个虚拟机全局共用的一个字符串常量池。

直接内存不是虚拟机运行时数据区的一部分，是在 JDK 1.4 后新引入了 NIO 后可以直接使用 native 方法操作的堆外内存，某些场景下可以减少数据在 Java 堆内外来回复制的的操作提升 IO 效率。



## 题目 02- 描述一个 Java 对象的生命周期

- 解释一个对象的创建过程
- 解释一个对象的内存分配
- 解释一个对象的销毁过程
- 对象的 2 种访问方式是什么？
- 为什么需要内存担保？

### 答：

1、**对象的创建过程**

当 Java 虚拟机遇到一条 new 指令时，首先是去常量池中检查这个指令的参数是否定位到一个类的符号引用，然后检查这个符号引用代表的类是否已被加载，如果没有就先要进行类加载。

已经被加载的，接下来虚拟机就为新对象分配内存空间，并把内存空间初始化为默认零值。

之后再进行必要的信息设置，主要是对象头中的值，比如：元数据信息、对象的哈希码、相关锁信息等。

最后再执行类的构造方法，至此一个对象就被完整的创建出来了。

2、**对象的内存分配** 

对象内存的分配方式主要有两种：一个是“指针碰撞”，一个是“空闲列表”。

“指针碰撞”：假设 Java 堆中的内存是绝对规整的，使用过的内存被放在一边，没有使用过的被放在另一边，中间有一个作为分界点的指示器，此时给对象分配内存，只需把指示器向没有使用过的一边移动该对象的大小即可。

“空闲列表”：如果 Java 堆内存不是绝对规整的，使用过的内存和没使用的交错在一起，则虚拟机需要维护一个列表记录，哪些内存地址是使用了的，哪些是没使用的。给新对象分配内存时，从这个列表未使用的地址中找一块足够大的划给新对象，并在列表上记录为已使用。

3、**对象的销毁过程** 

当 Java 虚拟机堆中的对象没有被引用的时候，我们就称这个对象为垃圾对象，就需要把它占用的内存进行回收，这个过程就是 JVM 中对象的销毁过程，也叫做垃圾回收。

首先，我们需要判断一个对象怎么算是没有引用了，这里有两个算法：引用计数算法、可达性分析算法。引用计数算法是判断一个对象的被引用次数是否为零，为零则为垃圾对象，这里有个缺点就是循环引用，导致对象一直都有引用。可达性分析算法是判断对象是否能沿着一条引用链和一些称为“GC Roots”的根对象相连，如果没有，则判定为需要回收。

其中的这个引用，在 Java 中有四种类型，分为：强引用、弱引用、软引用、虚引用。

当一个对象被判定为垃圾对象进行回收前，还会最后执行一次它的 finalize 方法，如果执行了之后还是没有有效的引用，则就会被销毁。

4、**对象的两种访问方式** 

Java 程序是通过栈上面的 reference 数据来操作堆上的具体对象。reference 保存的是一个地址值，这个可以是一个对象的句柄，也可以是对象的地址。

5、**为什么需要内存担保** 

首先我们来看，什么是内存担保：当 Eden 区存储不下新分配的对象的时候，会触发 minorGC，当 minorGC 后 正常情况下 Eden 区还存活的对象应该放入 Survivor 区，当该对象太大了无法直接放进 Survivor 区时，此时触发内存担保机制，该对象就会直接转移至老年代，此时 Eden 区就有空间存放新分配的对象。

所以，有了内存担保机制，就能充分利用堆中不同的区域的内存来进行对象存储，提高堆的利用率和可靠性。



## 题目 03- 垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？

- ParNew 收集器
- ParallelScavenge 收集器
- ParallelOld 收集器
- CMS 收集器
- G1 收集器