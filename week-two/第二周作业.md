第二周作业

# JVM 虚拟机论述题

## 题目 01- 请你用自己的语言向我介绍 Java 运行时数据区（内存区域）

- 堆、虚拟机栈、本地方法栈、方法区（永久代、元空间）、运行时常量池（字符串常量池）、直接内存
- 为什么堆内存要分年轻代和老年代？

### 答：

Java 虚拟机在执行 Java 程序的过程中，会把它管理的内存划分为若干个不同的数据区域，包含：堆、虚拟机栈、本地方法栈、方法区（包含运行时常量池）、程序计数器，这些区域统称为 Java 运行时数据区。

其中的堆、方法区是所有线程共享的，虚拟机栈、本地方法栈、程序计数器是当前线程私有的。

Java 堆在 Java 虚拟机启动时被创建的，唯一目的是存放对象实例，是虚拟机管理的最大的一块内存区域，也是垃圾收集器管理的区域。其中存放的 Java 对象实例是有生命周期的，会产生，也会销毁。为了更好的管理堆内存，我们通常把堆内存分为新生代和老年代（JDK 1.8）两个主要区域，新生代中又分为 Eden、Survivor空间。新生代主要存放新生成的对象，当进行一定次数的垃圾回收后还存活的对象就会被转移至老年代。Java 堆的大小是可拓展的，可以通过参数来进行设定，当堆内存满了后，Java 虚拟机会抛出 OutOfMemoryError 异常。

虚拟机栈是描述 Java 方法执行的线程内存模型，生命周期和线程相同，用于存放线程执行时调用的方法，每个被执行的方法都会生成一个栈帧，以栈帧的形式存放进虚拟机栈中，栈帧中保存了局部变量表、操作数栈、动态连接、方法出口等信息。栈帧以先进后出的方式保存在虚拟机栈中。

本地方法栈是虚拟机为执行本地方法服务的。

方法区是用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。方法区的具体实现在不同版本的 Java 中是不同的，JDK 1.8 前实现是永久代，JDK 1.8 后实现是元空间。永久代是存放在虚拟机进程所使用的区域，会影响虚拟机可使用的内存大小，元空间是使用了虚拟机外的本地内存。具体来说，元空间是把方法区原先包含的字符串常量池、静态变量等挪到堆后的剩余内容（主要是类型信息）。

运行时常量池属于方法区的一部分，一个 Class 文件对应一个运行时常量池，其中又有一个整个虚拟机全局共用的一个字符串常量池。

直接内存不是虚拟机运行时数据区的一部分，是在 JDK 1.4 后新引入了 NIO 后可以直接使用 native 方法操作的堆外内存，某些场景下可以减少数据在 Java 堆内外来回复制的的操作提升 IO 效率。



## 题目 02- 描述一个 Java 对象的生命周期

- 解释一个对象的创建过程
- 解释一个对象的内存分配
- 解释一个对象的销毁过程
- 对象的 2 种访问方式是什么？
- 为什么需要内存担保？



## 题目 03- 垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？

- ParNew 收集器
- ParallelScavenge 收集器
- ParallelOld 收集器
- CMS 收集器
- G1 收集器