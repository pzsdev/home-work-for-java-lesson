第二周作业

# JVM 虚拟机论述题

## 题目 01- 请你用自己的语言向我介绍 Java 运行时数据区（内存区域）

- 堆、虚拟机栈、本地方法栈、方法区（永久代、元空间）、运行时常量池（字符串常量池）、直接内存
- 为什么堆内存要分年轻代和老年代？



**答**：

Java 虚拟机在执行 Java 程序的过程中，会把它管理的内存划分为若干个不同的数据区域，包含：堆、虚拟机栈、本地方法栈、方法区（包含运行时常量池）、程序计数器，这些区域统称为 Java 运行时数据区。

其中的堆、方法区是所有线程共享的，虚拟机栈、本地方法栈、程序计数器是当前线程私有的。

Java 堆在 Java 虚拟机启动时被创建的，唯一目的是存放对象实例，是虚拟机管理的最大的一块内存区域，也是垃圾收集器管理的区域。其中存放的 Java 对象实例是有生命周期的，会产生，也会销毁。为了更好的管理堆内存，我们通常把堆内存分为新生代和老年代（JDK 1.8）两个主要区域，新生代中又分为 Eden、Survivor空间。新生代主要存放新生成的对象，当进行一定次数的垃圾回收后还存活的对象就会被转移至老年代。Java 堆的大小是可拓展的，可以通过参数来进行设定，当堆内存满了后，Java 虚拟机会抛出 OutOfMemoryError 异常。

虚拟机栈是描述 Java 方法执行的线程内存模型，生命周期和线程相同，用于存放线程执行时调用的方法，每个被执行的方法都会生成一个栈帧，以栈帧的形式存放进虚拟机栈中，栈帧中保存了局部变量表、操作数栈、动态连接、方法出口等信息。栈帧以先进后出的方式保存在虚拟机栈中。

本地方法栈是虚拟机为执行本地方法服务的。

方法区是用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。方法区的具体实现在不同版本的 Java 中是不同的，JDK 1.8 前实现是永久代，JDK 1.8 后实现是元空间。永久代是存放在虚拟机进程所使用的区域，会影响虚拟机可使用的内存大小，元空间是使用了虚拟机外的本地内存。具体来说，元空间是把方法区原先包含的字符串常量池、静态变量等挪到堆后的剩余内容（主要是类型信息）。

运行时常量池属于方法区的一部分，一个 Class 文件对应一个运行时常量池，其中又有一个整个虚拟机全局共用的一个字符串常量池。

直接内存不是虚拟机运行时数据区的一部分，是在 JDK 1.4 后新引入了 NIO 后可以直接使用 native 方法操作的堆外内存，某些场景下可以减少数据在 Java 堆内外来回复制的的操作提升 IO 效率。



## 题目 02- 描述一个 Java 对象的生命周期

- 解释一个对象的创建过程
- 解释一个对象的内存分配
- 解释一个对象的销毁过程
- 对象的 2 种访问方式是什么？
- 为什么需要内存担保？



**答**：

1、**对象的创建过程**

当 Java 虚拟机遇到一条 new 指令时，首先是去常量池中检查这个指令的参数是否定位到一个类的符号引用，然后检查这个符号引用代表的类是否已被加载，如果没有就先要进行类加载。

已经被加载的，接下来虚拟机就为新对象分配内存空间，并把内存空间初始化为默认零值。

之后再进行必要的信息设置，主要是对象头中的值，比如：元数据信息、对象的哈希码、相关锁信息等。

最后再执行类的构造方法，至此一个对象就被完整的创建出来了。

2、**对象的内存分配** 

对象内存的分配方式主要有两种：一个是“指针碰撞”，一个是“空闲列表”。

“指针碰撞”：假设 Java 堆中的内存是绝对规整的，使用过的内存被放在一边，没有使用过的被放在另一边，中间有一个作为分界点的指示器，此时给对象分配内存，只需把指示器向没有使用过的一边移动该对象的大小即可。

“空闲列表”：如果 Java 堆内存不是绝对规整的，使用过的内存和没使用的交错在一起，则虚拟机需要维护一个列表记录，哪些内存地址是使用了的，哪些是没使用的。给新对象分配内存时，从这个列表未使用的地址中找一块足够大的划给新对象，并在列表上记录为已使用。

3、**对象的销毁过程** 

当 Java 虚拟机堆中的对象没有被引用的时候，我们就称这个对象为垃圾对象，就需要把它占用的内存进行回收，这个过程就是 JVM 中对象的销毁过程，也叫做垃圾回收。

首先，我们需要判断一个对象怎么算是没有引用了，这里有两个算法：引用计数算法、可达性分析算法。引用计数算法是判断一个对象的被引用次数是否为零，为零则为垃圾对象，这里有个缺点就是循环引用，导致对象一直都有引用。可达性分析算法是判断对象是否能沿着一条引用链和一些称为“GC Roots”的根对象相连，如果没有，则判定为需要回收。

其中的这个引用，在 Java 中有四种类型，分为：强引用、弱引用、软引用、虚引用。

当一个对象被判定为垃圾对象进行回收前，还会最后执行一次它的 finalize 方法，如果执行了之后还是没有有效的引用，则就会被销毁。

4、**对象的两种访问方式** 

Java 程序是通过栈上面的 reference 数据来操作堆上的具体对象。reference 保存的是一个地址值，这个可以是一个对象的句柄，也可以是对象的地址。

5、**为什么需要内存担保** 

首先我们来看，什么是内存担保：当 Eden 区存储不下新分配的对象的时候，会触发 minorGC，当 minorGC 后 正常情况下 Eden 区还存活的对象应该放入 Survivor 区，当该对象太大了无法直接放进 Survivor 区时，此时触发内存担保机制，该对象就会直接转移至老年代，此时 Eden 区就有空间存放新分配的对象。

所以，有了内存担保机制，就能充分利用堆中不同的区域的内存来进行对象存储，提高堆的利用率和可靠性。



## 题目 03- 垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？

- ParNew 收集器
- ParallelScavenge 收集器
- ParallelOld 收集器
- CMS 收集器
- G1 收集器



**答**：

1、垃圾收集算法主要有三种：标记-清除算法、标记-复制算法、标记-整理算法。

**标记-清除算法** ：首先标记需要清除的对象，在标记完成后，然后对被标记的对象进行统一的回收。这个算法有两个缺点：一是需要进行大量的标记清除动作；二是会造成内存地址的碎片化。

**标记-复制算法** ：通过将内存划分为大小相等的两块，每次只使用其中的一块，当一块用完了，就把还存活的对象复制到另一块上，再把之前那块内存空间一次性清理掉。对于大多数对象是可回收的情况，只需移动少量对象，此时效率较高。缺点就是，可使用内存减小了一半，内存空间浪费太大。主要用于年轻代。

**标记-整理算法** ：针对标记-复制算法会造成内存空间的大量浪费，标记-整理算法则是先标记存活的对象，然后把他们整体向内存的一端移动，最后直接清理掉边界外的内存。这样内存就会相对规整，再次分配时，可用空间都是连续的。此方法缺点是，如果存在大量的存活对象，则移动对象的成本比较大。主要在老年代使用。

2、垃圾收集器有这些：Serial 收集器、ParNew 收集器、Parallel Scavenge 收集器、Serial Old 收集器、Parallel Old 收集器、CMS 收集器、G1 收集器等。

按使用区域区分：

年轻代使用：Serial 收集器、ParNew 收集器、Parallel Scavenge 收集器。

老年代使用：Serial Old 收集器、Parallel Old 收集器、CMS 收集器。

二者通用：G1 收集器。

Serial 收集器是单线程工作的收集器，它进行垃圾回收时，必须停止其他的所有工作线程也就是 STW，基于标记-复制算法进行垃圾回收，主要是虚拟机用在资源较少的 CPU 单核或者客户端模式下使用。

ParNew 收集器是多线程并行版的 Serial，主要区别是进行垃圾回收时是多线程同时进行，它只在多核 CPU 的情况下回收效率比 Serial 好。

Parallel Scavenge 收集器也是多线程并行进行垃圾回收的，主要特点是关注吞吐量，可以配置运行用户代码和进行垃圾回收时间的占比。也是基于标记-复制算法。

Serial Old 收集器是 Serial 的老年代版本，采用标记-整理算法。一般也在客户端模式下使用，在服务端时，主要和 Parallel Scavenge 收集器搭配使用，或作为 CMS 的后备使用。

Parallel Old 收集器是 Parallel Scavenge 的老年代版本，基于标记-整理算法，主要用来搭配 Parallel Scavenge 使用。

CMS 收集器是 Concurrent Mark Sweep 的缩写，基于标记-清除算法，主要有四个步骤：初始标记、并发标记、重新标记、并发清除，是以获取最短回收停顿为目标的收集器，但是垃圾回收本身需要的硬件资源比较多，而且标记-清除算法会造成内存空间碎片过多。

G1 收集器对堆内存进行了更加精细化的管理，它把整个堆分成若干份 region，每个 region 都可以是年轻代或者老年代，然后再进行管理，比较适合大内存的场景，由于模式更复杂，消耗的资源也更多。